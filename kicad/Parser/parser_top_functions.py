import parserprint
import aux_functions
from sexpdata import loads,car,cdr
import re

def checkArgs(args):
    input_file=''
    output_file=''
    length = len(args)
    if length == 3 and (args[1]=="--input" or args[1]=="-i"):
        input_file = args[2]
        parserprint.output_missing()
        output_file='autogenerated.ck'
    elif length == 5 and ((args[1]=="--input" and args[3]=="--output") or (args[1]=="-i" and args[3]=="-o")):
            input_file=args[2]
            output_file=args[4]
    elif length == 5 and ((args[3]=="--input" and args[1]=="--output") or (args[3]=="-i" and args[1]=="-o")):
            input_file=args[4]
            output_file=args[2]
    else:
        if length == 2 and (args[1]=="--help" or args[1]=="-h"):
            parserprint.help()
        else:
            parserprint.args_error()
        exit(0)
    return [input_file,output_file]

def readValues(input_file):
    netlist_file = ""
    lib_file=""
    sch_file=""
    f = open(input_file,"r")
    for file_read in f:
        file_cut = file_read.split()[0].split("=")
        if file_cut[0] == "netlist":
            netlist_file = file_cut[1]
        elif file_cut[0] == "library":
            lib_file = file_cut[1]
        elif file_cut[0] == "schematic":
            sch_file = file_cut[1]
    f.close()
    f = open(netlist_file, "r")
    netList = loads(f.read())
    modulesList = []
    definitionDict = {}
    connectionList = []
    for sheet in netList[2]:
        if isinstance(sheet, list):
            if aux_functions.symbol_value(str(sheet[0])) == "sheet":
                if aux_functions.symbol_value(str(sheet[2][1])) == "/":
                    modulesList.append(aux_functions.symbol_value(str(sheet[2][1])))
                    modulesList.append([])
                    modulesList.append(aux_functions.symbol_value(str(sheet[4][5][1])))
                else :
                    modulesList[1].append([aux_functions.symbol_value(str(sheet[2][1])),[],aux_functions.symbol_value(str(sheet[4][5][1]))])

    for component in netList[3]:
        if isinstance(component, list):
            if aux_functions.symbol_value(str(component[0])) == "comp":
                modulesList[1].append([aux_functions.symbol_value(str(component[4][1][1])) + aux_functions.symbol_value(str(component[1][1])) + '/',[],aux_functions.symbol_value(str(component[2][1]))])
    f.close()
    f = open(lib_file,"r")
    temp_line = []
    for line_read in f:
        line = line_read.split()
        if line[0] == 'DEF':
            temp_line.append(line[1])
        elif line[0]=='X':
            if line[11]=='I':
                temp_line.append([line[1],"in"])
            elif line[11]=='O':
                temp_line.append([line[1],"out"])
            elif line[11]=='B':
                temp_line.append([line[1],"inout"])
        elif line[0]=="ENDDEF":
            definitionDict.update({temp_line[0]:temp_line[1:]})
            temp_line = []
    f.close()
    paternity_test = []
    for i,child in enumerate(modulesList[1]):
        is_child = 0
        parent_id = 0
        for j,parent in enumerate(modulesList[1]):
            if i!=j and parent[0] == child[0][0:child[0][:-1].rfind('/')+1] and parent[0]!='':
                is_child=1
                parent_id=j
        paternity_test.append([is_child,parent_id,0,0])
    tested_subjects = len(paternity_test)
    family_tree_construction = 1
    while(family_tree_construction):
        for i in range(tested_subjects):
            if paternity_test[i][0]: 
                paternity_test[paternity_test[i][1]][2]=1
        for i in range(tested_subjects):
            if paternity_test[i][0] and not paternity_test[i][2]:
                modulesList[1][paternity_test[i][1]][1].append(modulesList[1][i])
                paternity_test[i][0]=0
                paternity_test[i][3]=1
        family_tree_construction = 0
        for i in range(tested_subjects):
            family_tree_construction+=paternity_test[i][0]
    for i in reversed(range(tested_subjects)):
        if paternity_test[i][3]:
            del modulesList[1][i]
    resultList = [modulesList,definitionDict]
    return resultList
    """
        if isinstance(header, list):

            if symbol_value(str(header[0])) == "libparts": # libparts contains the name of the modules.
                i = 0
                while i<len(header):
                    if(isinstance(header[i],list) and len(header[i])>=3):
                        if(isinstance(header[i][2],list) and len(header[i])>=2):
                            modules.add(symbol_value(str(header[i][2][1]))) # We add the name of the modules 
                            moduleSignals[symbol_value(str(header[i][2][1]))] = {}

                            if isinstance(header[i],list):
                                for sect in header[i]:
                                    if isinstance(sect,list) and symbol_value(str(sect[0])):
                                        for pins in sect: # We cannot fix the value to 4, we must look for the one that is "pins".
                                            if isinstance(pins,list) and len(pins) == 4:
                                                if len(pins[2]) > 2: # If the name of the pin has brackets, the imported library chops it in a non-desired manner.
                                                    name_1, bracket = bracket_value(pins[2][1])
                                                    # print(name_1)
                                                    # print(bracket)
                                                    # We take care of the name of the pins with brackets.
                                                    moduleSignals[symbol_value(str(header[i][2][1]))][pins[1][1]] = [symbol_value(str(pins[2][2])), [str(bracket)+str(name_1)+"]",symbol_value(str(pins[3][1]))]] 
                                                else:
                                                    # And those without them, we take care of them in a different manner.
                                                    moduleSignals[symbol_value(str(header[i][2][1]))][pins[1][1]] = [symbol_value(str(pins[2][1])), ["",symbol_value(str(pins[3][1]))]]


                    i+=1
            
            
            if symbol_value(str(header[0])) == "nets":
                for net in header:
                    if isinstance(net,list):
                        id = net[1][1]

                        # First indexing to get the module name from the instance, second index to index the pin, third index to index the type of the pin.
                        if "Symbol" not in str(net[2][1]): # Signals that come from the top modules use the Symbol name convention.
                            
                            if (moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][1][1] == "output" or moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][1][1] == "bidireccional") and moduleSignals[dicModName[symbol_value(str(net[4][1][1]))]][net[4][2][1]][1][1] == "input":

                                name_ins_out = symbol_value(str(net[3][1][1])) # Module that outputs the signal.
                                name_ins_in = symbol_value(str(net[4][1][1])) # Module that inputs the signal.
                                

                                outpt = moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][0] # Output signal
                                inpt = moduleSignals[dicModName[symbol_value(str(net[4][1][1]))]][net[4][2][1]][0] # Input signal
                                inpt = inpt.replace("_","")
                                
                                width = moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][1][0] # The width that will be concatenated to the output signal.

                            elif (moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][1][1] == "input" or moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][1][1] == "bidireccional") and moduleSignals[dicModName[symbol_value(str(net[4][1][1]))]][net[4][2][1]][1][1] == "output":

                                name_ins_in = symbol_value(str(net[3][1][1])) # Module that inputs the signal.
                                
                                name_ins_out = symbol_value(str(net[4][1][1])) # Module that outputs the signal.

                                inpt = moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][0] # Input signal

                                inpt = inpt.replace("_","")
                                    
                                outpt = moduleSignals[dicModName[symbol_value(str(net[4][1][1]))]][net[4][2][1]][0] # Output signal

                                
                                width = moduleSignals[dicModName[symbol_value(str(net[4][1][1]))]][net[4][2][1]][1][0] # The width that will be concatenated to the output signal.

                            else:
                                print("Error, pins wrong connection between %s %s.%s and %s %s.%s"%(moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][1][1], symbol_value(str(net[3][1][1])), moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][0], moduleSignals[dicModName[symbol_value(str(net[4][1][1]))]][net[4][2][1]][1][1], symbol_value(str(net[4][1][1])), moduleSignals[dicModName[symbol_value(str(net[4][1][1]))]][net[4][2][1]][0]))
                                exit()

                            wires.append(wire(id, name_ins_out, name_ins_in, outpt, inpt, width))

                        else:
                            width = ""
                            name = ""
                            if len(net[2]) > 2: # If the width of the signal is specified.

                                name = symbol_value(str(net[2][2])).replace("_","") # We get the name to use it as a key and remove the underscore used for the width.
                                print(name)
                                name_1, bracket = bracket_value(net[2][1])

                                width = bracket + name_1 + "]"

                                topSignals[name] = {}

                            else:
                                name = symbol_value(str(net[2][1]))
                                topSignals[name] = {}
                            modulesToSignal = {}
                            if isinstance(net,list):
                                for mod in net:
                                    if isinstance(mod,list) and len(mod)>=3 and symbol_value(str(mod[0])) == "node":

                                        modulesToSignal[symbol_value(str(mod[1][1]))] = moduleSignals[dicModName[symbol_value(str(mod[1][1]))]][net[3][2][1]][0]

                                topSignals[name] = [modulesToSignal, width, moduleSignals[dicModName[symbol_value(str(net[3][1][1]))]][net[3][2][1]][1][1]]
    """
def writeValues():
    f_skeletor = open(outputFile,"w+")
    for mod in modules:
        parameterSet = set()
        f_skeletor.write("module %s("%mod)
        it = 1
        for key,value in moduleSignals[mod].items():
            #f_skeletor.write("%s"%value[1][0])
            if value[1][0]!="":
                strng = value[1][0]
                length = len(strng)
                middle = strng.find(':')
                operatorA = -1
                operatorB = -1
                for op in operators:
                    if operatorA==-1:
                        operatorA = strng[0:middle].find(op)
                    if operatorB==-1:
                        operatorB = strng[middle+1:length-1].find(op)
                if operatorA==-1:
                    left = strng[1:middle]
                else:
                    left = strng[1:operatorA]
                if operatorB==-1:
                    right = strng[middle+1:length-1]
                else: 
                    right = strng[middle+1:operatorB]
                if not left.isdigit():
                    parameterSet.add(left)
                if not right.isdigit():
                    parameterSet.add(right)
        for param in parameterSet:
            if it < len(parameterSet) :
                f_skeletor.write("%s,"%param)
            else:
                f_skeletor.write("%s"%param)
            it+=1
        f_skeletor.write("){\n")
        for key,value in moduleSignals[mod].items():
            f_skeletor.write("    ")
            if value[1][1] == "input":
                f_skeletor.write("in %s %s;\n" % (value[1][0], value[0]))
            elif value[1][1] == "output":
                f_skeletor.write("out %s %s;\n" % (value[1][0], value[0]))
            else :
                f_skeletor.write("inout %s %s;\n" % (value[1][0], value[0]))
        f_skeletor.write("}\n\n")
    f_skeletor.write("module top main(")

    parameterSet = set()
    for w in wires:
        if w.width!="":
            strng = w.width
            length = len(strng)
            middle = strng.find(':')
            operatorA = -1
            operatorB = -1
            for op in operators:
                if operatorA==-1:
                    operatorA = strng[0:middle].find(op)
                if operatorB==-1:
                    operatorB = strng[middle+1:length-1].find(op)
            if operatorA==-1:
                left = strng[1:middle]
            else:
                left = strng[1:operatorA]
            if operatorB==-1:
                right = strng[middle+1:length-1]
            else:
                right = strng[middle+1:operatorB]
            if not left.isdigit():
                parameterSet.add(left)
            if not right.isdigit():
                parameterSet.add(right)
    it=1
    for param in parameterSet:
        if it < len(parameterSet) :
            f_skeletor.write("%s,"%param)
        else:
            f_skeletor.write("%s"%param)
        it+=1
    f_skeletor.write("){\n")

    type_c='in'
    for signal,signal_data in topSignals.items():
        if signal_data[2]=='input':
            type_c = 'in'
        elif signal_data[2]=='output':
            type_c = 'out'
        else:
            type_c = 'inout'
        f_skeletor.write("    %s %s %s;\n"%(type_c,signal_data[1],signal))
    f_skeletor.write("\n")
    for instance,module in dicModName.items() :
        f_skeletor.write("    %s:%s(){\n"%(module,instance))
        connection_buffer = []
        counter=0
        for signal,signal_data in topSignals.items():
            for instance_connected,pin in signal_data[0].items():
                if instance_connected == instance:
                    counter = counter+1
                    if signal_data[2]=='input':
                        type_c='in'
                    elif signal_data[2]=='output':
                        type_c='out'
                    else:
                        type_c='inout'

                    connection_buffer.append("        " + type_c + " " + signal_data[1] + " " + pin + " = " + type_c + " " + signal)
        for connection in connection_buffer:
            f_skeletor.write(connection)
            if counter > 1:
                f_skeletor.write(",\n")
            else:
                f_skeletor.write("\n")
            counter = counter-1
        f_skeletor.write("    };\n\n")
    for cable in wires:
        f_skeletor.write("    %s;\n"%cable.wire_output)
    f_skeletor.write("}\n")
    f_skeletor.close()